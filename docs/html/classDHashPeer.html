<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>P2P DHTS: DHashPeer Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">P2P DHTS
   &#160;<span id="projectnumber">0.0</span>
   </div>
   <div id="projectbrief">A C++ 20 library providing an implementation of the Chord and DHash protocols.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-types">Protected Types</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-static-methods">Static Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="classDHashPeer-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">DHashPeer Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="dhash__peer_8h_source.html">dhash_peer.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for DHashPeer:</div>
<div class="dyncontent">
<div class="center"><img src="classDHashPeer__inherit__graph.png" border="0" usemap="#aDHashPeer_inherit__map" alt="Inheritance graph"/></div>
<map name="aDHashPeer_inherit__map" id="aDHashPeer_inherit__map">
<area shape="rect" title=" " alt="" coords="29,80,124,107"/>
<area shape="rect" href="classAbstractChordPeer.html" title=" " alt="" coords="5,5,148,32"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for DHashPeer:</div>
<div class="dyncontent">
<div class="center"><img src="classDHashPeer__coll__graph.png" border="0" usemap="#aDHashPeer_coll__map" alt="Collaboration graph"/></div>
<map name="aDHashPeer_coll__map" id="aDHashPeer_coll__map">
<area shape="rect" title=" " alt="" coords="811,197,905,223"/>
<area shape="rect" href="classAbstractChordPeer.html" title=" " alt="" coords="619,149,761,175"/>
<area shape="rect" href="classGenericKey.html" title=" " alt="" coords="165,5,341,47"/>
<area shape="rect" href="classRemotePeerList.html" title=" " alt="" coords="191,71,316,98"/>
<area shape="rect" href="classThreadSafe.html" title=" " alt="" coords="5,173,101,199"/>
<area shape="rect" href="classThreadSafeKey.html" title=" " alt="" coords="158,122,349,149"/>
<area shape="rect" href="classFingerTable.html" title=" " alt="" coords="151,173,356,199"/>
<area shape="rect" href="classThreadSafeRemotePeer.html" title=" " alt="" coords="165,223,341,250"/>
<area shape="rect" href="classGenericDB.html" title=" " alt="" coords="380,269,595,295"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:af81d9133e78ffc36fa964493acf03875"><td class="memItemLeft" align="right" valign="top"><a id="af81d9133e78ffc36fa964493acf03875"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>KeyRange</b> = std::pair&lt; <a class="el" href="classGenericKey.html">ChordKey</a>, <a class="el" href="classGenericKey.html">ChordKey</a> &gt;</td></tr>
<tr class="separator:af81d9133e78ffc36fa964493acf03875"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae52e605c0c670d6beafa06162e6b15ab"><td class="memItemLeft" align="right" valign="top"><a id="ae52e605c0c670d6beafa06162e6b15ab"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>DbEntry</b> = <a class="el" href="classMerkleTree.html">MerkleTree</a>&lt; <a class="el" href="classDataFragment.html">DataFragment</a> &gt;</td></tr>
<tr class="separator:ae52e605c0c670d6beafa06162e6b15ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2fa8a06ff391acbbc51b9b0af4ebd47"><td class="memItemLeft" align="right" valign="top"><a id="ad2fa8a06ff391acbbc51b9b0af4ebd47"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>KvMap</b> = std::map&lt; <a class="el" href="classGenericKey.html">ChordKey</a>, <a class="el" href="classDataFragment.html">DataFragment</a> &gt;</td></tr>
<tr class="separator:ad2fa8a06ff391acbbc51b9b0af4ebd47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a593fea36baf6884362dc3f328271fd77"><td class="memItemLeft" align="right" valign="top"><a id="a593fea36baf6884362dc3f328271fd77"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>KvPair</b> = std::pair&lt; <a class="el" href="classGenericKey.html">ChordKey</a>, <a class="el" href="classDataFragment.html">DataFragment</a> &gt;</td></tr>
<tr class="separator:a593fea36baf6884362dc3f328271fd77"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a27067dc2b5fbdcb151a639acbf2d75a4"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDHashPeer.html#a27067dc2b5fbdcb151a639acbf2d75a4">DHashPeer</a> (std::string ip_addr, int port, int num_replicas)</td></tr>
<tr class="separator:a27067dc2b5fbdcb151a639acbf2d75a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabd3c7ed5300ab82c358ca133570c338"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDHashPeer.html#aabd3c7ed5300ab82c358ca133570c338">DHashPeer</a> (const <a class="el" href="classDHashPeer.html">DHashPeer</a> &amp;rhs)=delete</td></tr>
<tr class="separator:aabd3c7ed5300ab82c358ca133570c338"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa75fa6d2aff66cd124789b992bebe0ee"><td class="memItemLeft" align="right" valign="top"><a id="aa75fa6d2aff66cd124789b992bebe0ee"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>DHashPeer</b> (<a class="el" href="classDHashPeer.html">DHashPeer</a> &amp;&amp;rhs) noexcept</td></tr>
<tr class="separator:aa75fa6d2aff66cd124789b992bebe0ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d1da6ff9c962aa535b83ff75a0a7a5b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDHashPeer.html#a0d1da6ff9c962aa535b83ff75a0a7a5b">~DHashPeer</a> ()</td></tr>
<tr class="separator:a0d1da6ff9c962aa535b83ff75a0a7a5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ee5dd5500b3a5fc1c379b957b602320"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDHashPeer.html#a8ee5dd5500b3a5fc1c379b957b602320">Create</a> (const std::string &amp;key, const std::string &amp;val) override</td></tr>
<tr class="separator:a8ee5dd5500b3a5fc1c379b957b602320"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1aed5f28f1f6f4cd007238d69e823ba"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDHashPeer.html#ad1aed5f28f1f6f4cd007238d69e823ba">Read</a> (const std::string &amp;key) override</td></tr>
<tr class="separator:ad1aed5f28f1f6f4cd007238d69e823ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a525294f074a2c18ffe34888554fc6fb2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDHashPeer.html#a525294f074a2c18ffe34888554fc6fb2">Fail</a> () override</td></tr>
<tr class="separator:a525294f074a2c18ffe34888554fc6fb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e16b2bd33c041ca12d655b931a4b1aa"><td class="memItemLeft" align="right" valign="top">std::tuple&lt; int, int, int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDHashPeer.html#a0e16b2bd33c041ca12d655b931a4b1aa">GetIdaParams</a> () const</td></tr>
<tr class="separator:a0e16b2bd33c041ca12d655b931a4b1aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6dbfe35b2d0fc6fd6a6e29f516c0009"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDHashPeer.html#ab6dbfe35b2d0fc6fd6a6e29f516c0009">SetIdaParams</a> (int n, int m, int p)</td></tr>
<tr class="separator:ab6dbfe35b2d0fc6fd6a6e29f516c0009"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classAbstractChordPeer"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classAbstractChordPeer')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classAbstractChordPeer.html">AbstractChordPeer</a></td></tr>
<tr class="memitem:a8c79d838c9a898eb2bfc6d72c24b3ba7 inherit pub_methods_classAbstractChordPeer"><td class="memItemLeft" align="right" valign="top"><a id="a8c79d838c9a898eb2bfc6d72c24b3ba7"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAbstractChordPeer.html#a8c79d838c9a898eb2bfc6d72c24b3ba7">GetIpAddr</a> () const</td></tr>
<tr class="memdesc:a8c79d838c9a898eb2bfc6d72c24b3ba7 inherit pub_methods_classAbstractChordPeer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Getters. Not even gonna bother commenting. <br /></td></tr>
<tr class="separator:a8c79d838c9a898eb2bfc6d72c24b3ba7 inherit pub_methods_classAbstractChordPeer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4811d6a1bc367e707feef239705e4a96 inherit pub_methods_classAbstractChordPeer"><td class="memItemLeft" align="right" valign="top"><a id="a4811d6a1bc367e707feef239705e4a96"></a>
unsigned short&#160;</td><td class="memItemRight" valign="bottom"><b>GetPort</b> () const</td></tr>
<tr class="separator:a4811d6a1bc367e707feef239705e4a96 inherit pub_methods_classAbstractChordPeer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57cd124d3e04ecaa26df8a0c86231c8f inherit pub_methods_classAbstractChordPeer"><td class="memItemLeft" align="right" valign="top"><a id="a57cd124d3e04ecaa26df8a0c86231c8f"></a>
<a class="el" href="classGenericKey.html">ChordKey</a>&#160;</td><td class="memItemRight" valign="bottom"><b>GetId</b> ()</td></tr>
<tr class="separator:a57cd124d3e04ecaa26df8a0c86231c8f inherit pub_methods_classAbstractChordPeer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3c1584240f104ef6ccf12664845532a inherit pub_methods_classAbstractChordPeer"><td class="memItemLeft" align="right" valign="top"><a id="aa3c1584240f104ef6ccf12664845532a"></a>
<a class="el" href="classGenericKey.html">ChordKey</a>&#160;</td><td class="memItemRight" valign="bottom"><b>GetMinKey</b> ()</td></tr>
<tr class="separator:aa3c1584240f104ef6ccf12664845532a inherit pub_methods_classAbstractChordPeer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f3ef6ae8da5ba978e6bc13a07577aed inherit pub_methods_classAbstractChordPeer"><td class="memItemLeft" align="right" valign="top"><a id="a2f3ef6ae8da5ba978e6bc13a07577aed"></a>
<a class="el" href="classFingerTable.html">ChordFingerTable</a>&#160;</td><td class="memItemRight" valign="bottom"><b>GetFingerTable</b> ()</td></tr>
<tr class="separator:a2f3ef6ae8da5ba978e6bc13a07577aed inherit pub_methods_classAbstractChordPeer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3760e12dcbb0b8c7412e04e2448ae89f inherit pub_methods_classAbstractChordPeer"><td class="memItemLeft" align="right" valign="top"><a id="a3760e12dcbb0b8c7412e04e2448ae89f"></a>
<a class="el" href="classRemotePeer.html">RemotePeer</a>&#160;</td><td class="memItemRight" valign="bottom"><b>GetPredecessor</b> ()</td></tr>
<tr class="separator:a3760e12dcbb0b8c7412e04e2448ae89f inherit pub_methods_classAbstractChordPeer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac64af5f58a7511035a3bb6fa3f217075 inherit pub_methods_classAbstractChordPeer"><td class="memItemLeft" align="right" valign="top"><a id="ac64af5f58a7511035a3bb6fa3f217075"></a>
std::vector&lt; <a class="el" href="classRemotePeer.html">RemotePeer</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>GetSuccessors</b> ()</td></tr>
<tr class="separator:ac64af5f58a7511035a3bb6fa3f217075 inherit pub_methods_classAbstractChordPeer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05e30c5b02a2946d2cbca8ef0729a93e inherit pub_methods_classAbstractChordPeer"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAbstractChordPeer.html#a05e30c5b02a2946d2cbca8ef0729a93e">StartChord</a> ()</td></tr>
<tr class="separator:a05e30c5b02a2946d2cbca8ef0729a93e inherit pub_methods_classAbstractChordPeer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8a45a5aec0481cda4c78beaa38ddf6f inherit pub_methods_classAbstractChordPeer"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAbstractChordPeer.html#ab8a45a5aec0481cda4c78beaa38ddf6f">Join</a> (const std::string &amp;gateway_ip, unsigned short gateway_port)</td></tr>
<tr class="separator:ab8a45a5aec0481cda4c78beaa38ddf6f inherit pub_methods_classAbstractChordPeer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49c1a632e7d271971f9c9ee32d068c3b inherit pub_methods_classAbstractChordPeer"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAbstractChordPeer.html#a49c1a632e7d271971f9c9ee32d068c3b">Leave</a> ()</td></tr>
<tr class="separator:a49c1a632e7d271971f9c9ee32d068c3b inherit pub_methods_classAbstractChordPeer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70d98d06f40d205eb1b8cb13fdb4cdee inherit pub_methods_classAbstractChordPeer"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classRemotePeer.html">RemotePeer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAbstractChordPeer.html#a70d98d06f40d205eb1b8cb13fdb4cdee">GetSuccessor</a> (const std::string &amp;unhashed_key)</td></tr>
<tr class="separator:a70d98d06f40d205eb1b8cb13fdb4cdee inherit pub_methods_classAbstractChordPeer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4de944b953060df502ef85dadd1da34c inherit pub_methods_classAbstractChordPeer"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classRemotePeer.html">RemotePeer</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAbstractChordPeer.html#a4de944b953060df502ef85dadd1da34c">GetNSuccessors</a> (const std::string &amp;unhashed_key, int n)</td></tr>
<tr class="separator:a4de944b953060df502ef85dadd1da34c inherit pub_methods_classAbstractChordPeer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab156839b5d64e0fcaa93b196ee968cd6 inherit pub_methods_classAbstractChordPeer"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classRemotePeer.html">RemotePeer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAbstractChordPeer.html#ab156839b5d64e0fcaa93b196ee968cd6">GetPredecessor</a> (const std::string &amp;unhashed_key)</td></tr>
<tr class="separator:ab156839b5d64e0fcaa93b196ee968cd6 inherit pub_methods_classAbstractChordPeer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c54b4216ebbdbdc6f48882798d8acba inherit pub_methods_classAbstractChordPeer"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classRemotePeer.html">RemotePeer</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAbstractChordPeer.html#a0c54b4216ebbdbdc6f48882798d8acba">GetNPredecessors</a> (const std::string &amp;unhashed_key, int n)</td></tr>
<tr class="separator:a0c54b4216ebbdbdc6f48882798d8acba inherit pub_methods_classAbstractChordPeer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a133b1cd61bc6e3c75587333dbefb71cc inherit pub_methods_classAbstractChordPeer"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAbstractChordPeer.html#a133b1cd61bc6e3c75587333dbefb71cc">UploadFile</a> (const std::string &amp;file_path)</td></tr>
<tr class="separator:a133b1cd61bc6e3c75587333dbefb71cc inherit pub_methods_classAbstractChordPeer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a119fff10400d48e4a36dc8486f73214f inherit pub_methods_classAbstractChordPeer"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAbstractChordPeer.html#a119fff10400d48e4a36dc8486f73214f">DownloadFile</a> (const std::string &amp;file_name, const std::string &amp;output_path)</td></tr>
<tr class="separator:a119fff10400d48e4a36dc8486f73214f inherit pub_methods_classAbstractChordPeer"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-types"></a>
Protected Types</h2></td></tr>
<tr class="memitem:ad614c3a43a33faaf1a40629e731a8ad0"><td class="memItemLeft" align="right" valign="top"><a id="ad614c3a43a33faaf1a40629e731a8ad0"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>ReqHandler</b> = std::function&lt; Json::Value(const Json::Value &amp;)&gt;</td></tr>
<tr class="separator:ad614c3a43a33faaf1a40629e731a8ad0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8759ae2d2ff4925b6934e89d1ad52fcb"><td class="memItemLeft" align="right" valign="top"><a id="a8759ae2d2ff4925b6934e89d1ad52fcb"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>ServerType</b> = <a class="el" href="classServer.html">Server</a>&lt; ReqHandler &gt;</td></tr>
<tr class="separator:a8759ae2d2ff4925b6934e89d1ad52fcb"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a1721f42ca0b431e635bf65f9f6d5aec1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDHashPeer.html#a1721f42ca0b431e635bf65f9f6d5aec1">Create</a> (const <a class="el" href="classGenericKey.html">ChordKey</a> &amp;key, const <a class="el" href="classDataBlock.html">DataBlock</a> &amp;val)</td></tr>
<tr class="separator:a1721f42ca0b431e635bf65f9f6d5aec1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b0dda4296dac27a8e9cf2b5aacdb298"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDHashPeer.html#a0b0dda4296dac27a8e9cf2b5aacdb298">Create</a> (const <a class="el" href="classGenericKey.html">ChordKey</a> &amp;key, const std::string &amp;val)</td></tr>
<tr class="separator:a0b0dda4296dac27a8e9cf2b5aacdb298"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0eb205320642065c6b675697210f073"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDHashPeer.html#ac0eb205320642065c6b675697210f073">CreateKey</a> (const <a class="el" href="classGenericKey.html">ChordKey</a> &amp;key, const <a class="el" href="classDataFragment.html">DataFragment</a> &amp;val, const <a class="el" href="classRemotePeer.html">RemotePeer</a> &amp;peer)</td></tr>
<tr class="separator:ac0eb205320642065c6b675697210f073"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf5c11885e4d9967ed785529e6fbd63c"><td class="memItemLeft" align="right" valign="top">Json::Value&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDHashPeer.html#abf5c11885e4d9967ed785529e6fbd63c">CreateKeyHandler</a> (const Json::Value &amp;req)</td></tr>
<tr class="separator:abf5c11885e4d9967ed785529e6fbd63c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93a21ab8e833c3130a7c681ad847d8b3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDataBlock.html">DataBlock</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDHashPeer.html#a93a21ab8e833c3130a7c681ad847d8b3">Read</a> (const <a class="el" href="classGenericKey.html">ChordKey</a> &amp;key)</td></tr>
<tr class="separator:a93a21ab8e833c3130a7c681ad847d8b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a891f9482080885d9196a0dd5582d6686"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDataFragment.html">DataFragment</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDHashPeer.html#a891f9482080885d9196a0dd5582d6686">ReadKey</a> (const <a class="el" href="classGenericKey.html">ChordKey</a> &amp;key, const <a class="el" href="classRemotePeer.html">RemotePeer</a> &amp;peer)</td></tr>
<tr class="separator:a891f9482080885d9196a0dd5582d6686"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af657f5dd4b09ef15e52a2c0d0ffcdb6b"><td class="memItemLeft" align="right" valign="top">Json::Value&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDHashPeer.html#af657f5dd4b09ef15e52a2c0d0ffcdb6b">ReadKeyHandler</a> (const Json::Value &amp;req)</td></tr>
<tr class="separator:af657f5dd4b09ef15e52a2c0d0ffcdb6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0e0205a816c06d7aa8d6c6dc7f64315"><td class="memItemLeft" align="right" valign="top">Json::Value&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDHashPeer.html#ac0e0205a816c06d7aa8d6c6dc7f64315">ReadRangeHandler</a> (const Json::Value &amp;request)</td></tr>
<tr class="separator:ac0e0205a816c06d7aa8d6c6dc7f64315"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab81aa53821650636d83a5e342085f297"><td class="memItemLeft" align="right" valign="top">Json::Value&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDHashPeer.html#ab81aa53821650636d83a5e342085f297">HandleNotifyFromPred</a> (const <a class="el" href="classRemotePeer.html">RemotePeer</a> &amp;new_pred) override</td></tr>
<tr class="separator:ab81aa53821650636d83a5e342085f297"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a620c9ed5d88456741e9111b75895a537"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDHashPeer.html#a620c9ed5d88456741e9111b75895a537">HandlePredFailure</a> (const <a class="el" href="classRemotePeer.html">RemotePeer</a> &amp;old_pred) override</td></tr>
<tr class="separator:a620c9ed5d88456741e9111b75895a537"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a912680ccaa6b09d390e83a325a2cbaa9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDHashPeer.html#a912680ccaa6b09d390e83a325a2cbaa9">StartMaintenance</a> () override</td></tr>
<tr class="separator:a912680ccaa6b09d390e83a325a2cbaa9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72b3488e32898089f02829c28f00632e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDHashPeer.html#a72b3488e32898089f02829c28f00632e">MaintenanceLoop</a> ()</td></tr>
<tr class="separator:a72b3488e32898089f02829c28f00632e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec950208fe2c1e7498a3f59564a29bf9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDHashPeer.html#aec950208fe2c1e7498a3f59564a29bf9">RunGlobalMaintenance</a> ()</td></tr>
<tr class="separator:aec950208fe2c1e7498a3f59564a29bf9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae435863093fde0cde366fe16cf90beea"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDHashPeer.html#ae435863093fde0cde366fe16cf90beea">RunLocalMaintenance</a> ()</td></tr>
<tr class="separator:ae435863093fde0cde366fe16cf90beea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c06a83f3e8284a9f2a906ef290529d4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDHashPeer.html#a7c06a83f3e8284a9f2a906ef290529d4">Synchronize</a> (const <a class="el" href="classRemotePeer.html">RemotePeer</a> &amp;succ, const KeyRange &amp;key_range)</td></tr>
<tr class="separator:a7c06a83f3e8284a9f2a906ef290529d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af795b89d0a2e23202e90efba685d8a9c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDHashPeer.html#af795b89d0a2e23202e90efba685d8a9c">SynchronizeHelper</a> (const <a class="el" href="classRemotePeer.html">RemotePeer</a> &amp;succ, const KeyRange &amp;key_range, const <a class="el" href="classMerkleTree.html">DbEntry</a> &amp;local_node)</td></tr>
<tr class="separator:af795b89d0a2e23202e90efba685d8a9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a068cb23863c783eef59284990f9390b8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classMerkleTree.html">DbEntry</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDHashPeer.html#a068cb23863c783eef59284990f9390b8">ExchangeNode</a> (const <a class="el" href="classRemotePeer.html">RemotePeer</a> &amp;succ, const <a class="el" href="classMerkleTree.html">DbEntry</a> &amp;node, const KeyRange &amp;key_range)</td></tr>
<tr class="separator:a068cb23863c783eef59284990f9390b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac060d8844b698e5829c1bc55c5f4d18d"><td class="memItemLeft" align="right" valign="top">Json::Value&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDHashPeer.html#ac060d8844b698e5829c1bc55c5f4d18d">ExchangeNodeHandler</a> (const Json::Value &amp;request)</td></tr>
<tr class="separator:ac060d8844b698e5829c1bc55c5f4d18d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1813ce13acd42cb92909ac1e833a6ca7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDHashPeer.html#a1813ce13acd42cb92909ac1e833a6ca7">CompareNodes</a> (const <a class="el" href="classMerkleTree.html">DbEntry</a> &amp;remote_node, const <a class="el" href="classMerkleTree.html">DbEntry</a> &amp;local_node, const <a class="el" href="classRemotePeer.html">RemotePeer</a> &amp;succ, const KeyRange &amp;key_range)</td></tr>
<tr class="separator:a1813ce13acd42cb92909ac1e833a6ca7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ac5191636b286290773c15e59cb092c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDHashPeer.html#a6ac5191636b286290773c15e59cb092c">IsMissing</a> (const <a class="el" href="classGenericKey.html">ChordKey</a> &amp;k, const KeyRange &amp;key_range)</td></tr>
<tr class="separator:a6ac5191636b286290773c15e59cb092c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5cdede7851008e5183bc99ddbbb0839"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDHashPeer.html#ae5cdede7851008e5183bc99ddbbb0839">RetrieveMissing</a> (const <a class="el" href="classGenericKey.html">ChordKey</a> &amp;key)</td></tr>
<tr class="separator:ae5cdede7851008e5183bc99ddbbb0839"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d5c983633a793168ac00f1fc829bec1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDHashPeer.html#a4d5c983633a793168ac00f1fc829bec1">AbsorbKeys</a> (const Json::Value &amp;kv_pairs) override</td></tr>
<tr class="separator:a4d5c983633a793168ac00f1fc829bec1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0502c246336a328e9337fe7462bf9393"><td class="memItemLeft" align="right" valign="top">Json::Value&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDHashPeer.html#a0502c246336a328e9337fe7462bf9393">KeysAsJson</a> () override</td></tr>
<tr class="separator:a0502c246336a328e9337fe7462bf9393"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8cd4bb0350bc4c25eddee0f4e27326a"><td class="memItemLeft" align="right" valign="top">Json::Value&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDHashPeer.html#ac8cd4bb0350bc4c25eddee0f4e27326a">ForwardRequest</a> (const <a class="el" href="classGenericKey.html">ChordKey</a> &amp;key, const Json::Value &amp;request) override</td></tr>
<tr class="separator:ac8cd4bb0350bc4c25eddee0f4e27326a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_classAbstractChordPeer"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_classAbstractChordPeer')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="classAbstractChordPeer.html">AbstractChordPeer</a></td></tr>
<tr class="memitem:a3d5c3e1d7e8fe3c11c79170d019ec2a6 inherit pro_methods_classAbstractChordPeer"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAbstractChordPeer.html#a3d5c3e1d7e8fe3c11c79170d019ec2a6">AbstractChordPeer</a> (std::string ip_addr, unsigned short port, int num_succs)</td></tr>
<tr class="separator:a3d5c3e1d7e8fe3c11c79170d019ec2a6 inherit pro_methods_classAbstractChordPeer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac57634d05a81437a9745475c31c0ab1 inherit pro_methods_classAbstractChordPeer"><td class="memItemLeft" align="right" valign="top"><a id="aac57634d05a81437a9745475c31c0ab1"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>AbstractChordPeer</b> (const <a class="el" href="classAbstractChordPeer.html">AbstractChordPeer</a> &amp;rhs)=delete</td></tr>
<tr class="separator:aac57634d05a81437a9745475c31c0ab1 inherit pro_methods_classAbstractChordPeer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a032654607db2a69d39e5cf5a64399470 inherit pro_methods_classAbstractChordPeer"><td class="memItemLeft" align="right" valign="top"><a id="a032654607db2a69d39e5cf5a64399470"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>AbstractChordPeer</b> (<a class="el" href="classAbstractChordPeer.html">AbstractChordPeer</a> &amp;&amp;rhs) noexcept</td></tr>
<tr class="separator:a032654607db2a69d39e5cf5a64399470 inherit pro_methods_classAbstractChordPeer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60f12169546fa91501ab0062f1d76c83 inherit pro_methods_classAbstractChordPeer"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAbstractChordPeer.html#a60f12169546fa91501ab0062f1d76c83">~AbstractChordPeer</a> ()</td></tr>
<tr class="separator:a60f12169546fa91501ab0062f1d76c83 inherit pro_methods_classAbstractChordPeer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaedba44c319fbf9eae9d08f4d5fca237 inherit pro_methods_classAbstractChordPeer"><td class="memItemLeft" align="right" valign="top">Json::Value&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAbstractChordPeer.html#aaedba44c319fbf9eae9d08f4d5fca237">JoinHandler</a> (const Json::Value &amp;req)</td></tr>
<tr class="separator:aaedba44c319fbf9eae9d08f4d5fca237 inherit pro_methods_classAbstractChordPeer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af226fe3276131a0d3d3903a907974034 inherit pro_methods_classAbstractChordPeer"><td class="memItemLeft" align="right" valign="top">Json::Value&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAbstractChordPeer.html#af226fe3276131a0d3d3903a907974034">LeaveHandler</a> (const Json::Value &amp;req)</td></tr>
<tr class="separator:af226fe3276131a0d3d3903a907974034 inherit pro_methods_classAbstractChordPeer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac92327c3155a02c444a45e3511b098f5 inherit pro_methods_classAbstractChordPeer"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAbstractChordPeer.html#ac92327c3155a02c444a45e3511b098f5">Notify</a> (const <a class="el" href="classRemotePeer.html">RemotePeer</a> &amp;peer_to_notify)</td></tr>
<tr class="separator:ac92327c3155a02c444a45e3511b098f5 inherit pro_methods_classAbstractChordPeer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa85bb328ef37760737886992882313ab inherit pro_methods_classAbstractChordPeer"><td class="memItemLeft" align="right" valign="top">Json::Value&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAbstractChordPeer.html#aa85bb328ef37760737886992882313ab">NotifyHandler</a> (const Json::Value &amp;req)</td></tr>
<tr class="separator:aa85bb328ef37760737886992882313ab inherit pro_methods_classAbstractChordPeer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae45ca2757a96a55dd1fe316117200dff inherit pro_methods_classAbstractChordPeer"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classRemotePeer.html">RemotePeer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAbstractChordPeer.html#ae45ca2757a96a55dd1fe316117200dff">GetSuccessor</a> (const <a class="el" href="classGenericKey.html">ChordKey</a> &amp;key)</td></tr>
<tr class="separator:ae45ca2757a96a55dd1fe316117200dff inherit pro_methods_classAbstractChordPeer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3eb2e3a6108d141b111a8a1aa47da16 inherit pro_methods_classAbstractChordPeer"><td class="memItemLeft" align="right" valign="top">Json::Value&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAbstractChordPeer.html#af3eb2e3a6108d141b111a8a1aa47da16">GetSuccHandler</a> (const Json::Value &amp;req)</td></tr>
<tr class="separator:af3eb2e3a6108d141b111a8a1aa47da16 inherit pro_methods_classAbstractChordPeer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b0c5b4679f2f3165887b487d101c3d9 inherit pro_methods_classAbstractChordPeer"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classRemotePeer.html">RemotePeer</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAbstractChordPeer.html#a5b0c5b4679f2f3165887b487d101c3d9">GetNSuccessors</a> (const <a class="el" href="classGenericKey.html">ChordKey</a> &amp;key, int n)</td></tr>
<tr class="separator:a5b0c5b4679f2f3165887b487d101c3d9 inherit pro_methods_classAbstractChordPeer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa94c34d2827144ab56eb840379a61fd2 inherit pro_methods_classAbstractChordPeer"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classRemotePeer.html">RemotePeer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAbstractChordPeer.html#aa94c34d2827144ab56eb840379a61fd2">GetPredecessor</a> (const <a class="el" href="classGenericKey.html">ChordKey</a> &amp;key)</td></tr>
<tr class="separator:aa94c34d2827144ab56eb840379a61fd2 inherit pro_methods_classAbstractChordPeer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab276e438fac0573056e1ec7b40d15f55 inherit pro_methods_classAbstractChordPeer"><td class="memItemLeft" align="right" valign="top">Json::Value&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAbstractChordPeer.html#ab276e438fac0573056e1ec7b40d15f55">GetPredHandler</a> (const Json::Value &amp;req)</td></tr>
<tr class="separator:ab276e438fac0573056e1ec7b40d15f55 inherit pro_methods_classAbstractChordPeer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a558fab5100ac2b66d19f28ee1407a097 inherit pro_methods_classAbstractChordPeer"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classRemotePeer.html">RemotePeer</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAbstractChordPeer.html#a558fab5100ac2b66d19f28ee1407a097">GetNPredecessors</a> (const <a class="el" href="classGenericKey.html">ChordKey</a> &amp;key, int n)</td></tr>
<tr class="separator:a558fab5100ac2b66d19f28ee1407a097 inherit pro_methods_classAbstractChordPeer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bf1668e3c54ed916969c6c313519a64 inherit pro_methods_classAbstractChordPeer"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAbstractChordPeer.html#a0bf1668e3c54ed916969c6c313519a64">Stabilize</a> ()</td></tr>
<tr class="separator:a0bf1668e3c54ed916969c6c313519a64 inherit pro_methods_classAbstractChordPeer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0cbd32965fd62231f9291b30ea1e30f inherit pro_methods_classAbstractChordPeer"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAbstractChordPeer.html#af0cbd32965fd62231f9291b30ea1e30f">UpdateSuccList</a> ()</td></tr>
<tr class="separator:af0cbd32965fd62231f9291b30ea1e30f inherit pro_methods_classAbstractChordPeer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb4957d9d140a38e73f3f5167f9df59c inherit pro_methods_classAbstractChordPeer"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAbstractChordPeer.html#acb4957d9d140a38e73f3f5167f9df59c">PopulateFingerTable</a> (bool initialize)</td></tr>
<tr class="separator:acb4957d9d140a38e73f3f5167f9df59c inherit pro_methods_classAbstractChordPeer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6ab34dc4d1d1cca9ea6fecb6e5ab95b inherit pro_methods_classAbstractChordPeer"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAbstractChordPeer.html#ad6ab34dc4d1d1cca9ea6fecb6e5ab95b">FixOtherFingers</a> (const <a class="el" href="classGenericKey.html">ChordKey</a> &amp;starting_key)</td></tr>
<tr class="separator:ad6ab34dc4d1d1cca9ea6fecb6e5ab95b inherit pro_methods_classAbstractChordPeer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ae12c7687233d11f3fcb14fbfefe975 inherit pro_methods_classAbstractChordPeer"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAbstractChordPeer.html#a8ae12c7687233d11f3fcb14fbfefe975">Rectify</a> (const <a class="el" href="classRemotePeer.html">RemotePeer</a> &amp;failed_peer)</td></tr>
<tr class="separator:a8ae12c7687233d11f3fcb14fbfefe975 inherit pro_methods_classAbstractChordPeer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a956447a01e99db83db0003df5abd11e8 inherit pro_methods_classAbstractChordPeer"><td class="memItemLeft" align="right" valign="top">Json::Value&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAbstractChordPeer.html#a956447a01e99db83db0003df5abd11e8">RectifyHandler</a> (const Json::Value &amp;req)</td></tr>
<tr class="separator:a956447a01e99db83db0003df5abd11e8 inherit pro_methods_classAbstractChordPeer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b0b4155cbb96a4cf6f6b239915d8511 inherit pro_methods_classAbstractChordPeer"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAbstractChordPeer.html#a9b0b4155cbb96a4cf6f6b239915d8511">StoredLocally</a> (const <a class="el" href="classGenericKey.html">ChordKey</a> &amp;key)</td></tr>
<tr class="separator:a9b0b4155cbb96a4cf6f6b239915d8511 inherit pro_methods_classAbstractChordPeer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6a30546186ccbf913152fa38e26cc06 inherit pro_methods_classAbstractChordPeer"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classRemotePeer.html">RemotePeer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAbstractChordPeer.html#ae6a30546186ccbf913152fa38e26cc06">ToRemotePeer</a> ()</td></tr>
<tr class="separator:ae6a30546186ccbf913152fa38e26cc06 inherit pro_methods_classAbstractChordPeer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38c7e0905ceb0a6cf8b0f5b836b6f196 inherit pro_methods_classAbstractChordPeer"><td class="memItemLeft" align="right" valign="top">Json::Value&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAbstractChordPeer.html#a38c7e0905ceb0a6cf8b0f5b836b6f196">PeerAsJson</a> ()</td></tr>
<tr class="separator:a38c7e0905ceb0a6cf8b0f5b836b6f196 inherit pro_methods_classAbstractChordPeer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6dec2aa888f32c279720e62e21d454ad inherit pro_methods_classAbstractChordPeer"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAbstractChordPeer.html#a6dec2aa888f32c279720e62e21d454ad">Log</a> (const std::string &amp;str)</td></tr>
<tr class="separator:a6dec2aa888f32c279720e62e21d454ad inherit pro_methods_classAbstractChordPeer"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-static-methods"></a>
Static Protected Member Functions</h2></td></tr>
<tr class="memitem:a0160c1a8585b5cad3e65fc0269869488"><td class="memItemLeft" align="right" valign="top">static KvMap&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDHashPeer.html#a0160c1a8585b5cad3e65fc0269869488">ReadRange</a> (const <a class="el" href="classRemotePeer.html">RemotePeer</a> &amp;succ, const KeyRange &amp;key_range)</td></tr>
<tr class="separator:a0160c1a8585b5cad3e65fc0269869488"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad10928a0f127ad3a36a856d72c2aa9b9"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDHashPeer.html#ad10928a0f127ad3a36a856d72c2aa9b9">NeedsSync</a> (const <a class="el" href="classMerkleTree.html">DbEntry</a> &amp;remote_node, const <a class="el" href="classMerkleTree.html">DbEntry</a> &amp;local_node, const KeyRange &amp;key_range)</td></tr>
<tr class="separator:ad10928a0f127ad3a36a856d72c2aa9b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:af7a8109daee7743c5c4b8dc62e0a4e70"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGenericDB.html">FragmentDb</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDHashPeer.html#af7a8109daee7743c5c4b8dc62e0a4e70">db_</a></td></tr>
<tr class="separator:af7a8109daee7743c5c4b8dc62e0a4e70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a630b7297b99632cd46ecc37a8e5f264d"><td class="memItemLeft" align="right" valign="top">std::thread&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDHashPeer.html#a630b7297b99632cd46ecc37a8e5f264d">maintenance_thread_</a></td></tr>
<tr class="separator:a630b7297b99632cd46ecc37a8e5f264d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc256eb563c9e77a7bde62c8df1d3125"><td class="memItemLeft" align="right" valign="top"><a id="adc256eb563c9e77a7bde62c8df1d3125"></a>
std::shared_ptr&lt; <a class="el" href="classServer.html">ServerType</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDHashPeer.html#adc256eb563c9e77a7bde62c8df1d3125">server_</a></td></tr>
<tr class="memdesc:adc256eb563c9e77a7bde62c8df1d3125"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classServer.html">Server</a> to respond to queries from other nodes. <br /></td></tr>
<tr class="separator:adc256eb563c9e77a7bde62c8df1d3125"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afde61f74ef37d45a28b6ff877d6bc056"><td class="memItemLeft" align="right" valign="top"><a id="afde61f74ef37d45a28b6ff877d6bc056"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDHashPeer.html#afde61f74ef37d45a28b6ff877d6bc056">continue_maintenance_</a></td></tr>
<tr class="memdesc:afde61f74ef37d45a28b6ff877d6bc056"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stabilize thread will run while this is true. <br /></td></tr>
<tr class="separator:afde61f74ef37d45a28b6ff877d6bc056"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac180b20f0267f87276378c35e4383f66"><td class="memItemLeft" align="right" valign="top"><a id="ac180b20f0267f87276378c35e4383f66"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>n_</b></td></tr>
<tr class="separator:ac180b20f0267f87276378c35e4383f66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04c43f597992878fd84d020a94d3b7d9"><td class="memItemLeft" align="right" valign="top"><a id="a04c43f597992878fd84d020a94d3b7d9"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>m_</b></td></tr>
<tr class="separator:a04c43f597992878fd84d020a94d3b7d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a181a188ec709e2a0f900a222b726feed"><td class="memItemLeft" align="right" valign="top"><a id="a181a188ec709e2a0f900a222b726feed"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>p_</b></td></tr>
<tr class="separator:a181a188ec709e2a0f900a222b726feed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_attribs_classAbstractChordPeer"><td colspan="2" onclick="javascript:toggleInherit('pro_attribs_classAbstractChordPeer')"><img src="closed.png" alt="-"/>&#160;Protected Attributes inherited from <a class="el" href="classAbstractChordPeer.html">AbstractChordPeer</a></td></tr>
<tr class="memitem:ad162036f63caa4d66ab2dd8cee64fff6 inherit pro_attribs_classAbstractChordPeer"><td class="memItemLeft" align="right" valign="top"><a id="ad162036f63caa4d66ab2dd8cee64fff6"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAbstractChordPeer.html#ad162036f63caa4d66ab2dd8cee64fff6">ip_addr_</a></td></tr>
<tr class="memdesc:ad162036f63caa4d66ab2dd8cee64fff6 inherit pro_attribs_classAbstractChordPeer"><td class="mdescLeft">&#160;</td><td class="mdescRight">IP addr on which peer runs. <br /></td></tr>
<tr class="separator:ad162036f63caa4d66ab2dd8cee64fff6 inherit pro_attribs_classAbstractChordPeer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4056b7d7d1e3173e5cd8a2c94887297d inherit pro_attribs_classAbstractChordPeer"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAbstractChordPeer.html#a4056b7d7d1e3173e5cd8a2c94887297d">port_</a></td></tr>
<tr class="separator:a4056b7d7d1e3173e5cd8a2c94887297d inherit pro_attribs_classAbstractChordPeer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fe7239afeb677feabfcdf83cc0a6cdf inherit pro_attribs_classAbstractChordPeer"><td class="memItemLeft" align="right" valign="top"><a id="a7fe7239afeb677feabfcdf83cc0a6cdf"></a>
const int&#160;</td><td class="memItemRight" valign="bottom"><b>num_succs_</b></td></tr>
<tr class="separator:a7fe7239afeb677feabfcdf83cc0a6cdf inherit pro_attribs_classAbstractChordPeer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a974116e0856ba93a9de6495f7946ea7a inherit pro_attribs_classAbstractChordPeer"><td class="memItemLeft" align="right" valign="top"><a id="a974116e0856ba93a9de6495f7946ea7a"></a>
const <a class="el" href="classGenericKey.html">ChordKey</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAbstractChordPeer.html#a974116e0856ba93a9de6495f7946ea7a">id_</a></td></tr>
<tr class="memdesc:a974116e0856ba93a9de6495f7946ea7a inherit pro_attribs_classAbstractChordPeer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Identifier of peer which will determine its placement in a logical ring. <br /></td></tr>
<tr class="separator:a974116e0856ba93a9de6495f7946ea7a inherit pro_attribs_classAbstractChordPeer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a329c1e37be99e72edd1eaea49650f296 inherit pro_attribs_classAbstractChordPeer"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classFingerTable.html">ChordFingerTable</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAbstractChordPeer.html#a329c1e37be99e72edd1eaea49650f296">finger_table_</a></td></tr>
<tr class="separator:a329c1e37be99e72edd1eaea49650f296 inherit pro_attribs_classAbstractChordPeer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4027c1fd38a657705425df054ea59c63 inherit pro_attribs_classAbstractChordPeer"><td class="memItemLeft" align="right" valign="top"><a id="a4027c1fd38a657705425df054ea59c63"></a>
<a class="el" href="classThreadSafeRemotePeer.html">ThreadSafeRemotePeer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAbstractChordPeer.html#a4027c1fd38a657705425df054ea59c63">predecessor_</a></td></tr>
<tr class="memdesc:a4027c1fd38a657705425df054ea59c63 inherit pro_attribs_classAbstractChordPeer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Predecessor of this peer. <br /></td></tr>
<tr class="separator:a4027c1fd38a657705425df054ea59c63 inherit pro_attribs_classAbstractChordPeer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a488c57c9114b486167396f20553bd8 inherit pro_attribs_classAbstractChordPeer"><td class="memItemLeft" align="right" valign="top"><a id="a2a488c57c9114b486167396f20553bd8"></a>
<a class="el" href="classRemotePeerList.html">RemotePeerList</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAbstractChordPeer.html#a2a488c57c9114b486167396f20553bd8">successors_</a></td></tr>
<tr class="memdesc:a2a488c57c9114b486167396f20553bd8 inherit pro_attribs_classAbstractChordPeer"><td class="mdescLeft">&#160;</td><td class="mdescRight">List of successors. <br /></td></tr>
<tr class="separator:a2a488c57c9114b486167396f20553bd8 inherit pro_attribs_classAbstractChordPeer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e890e9063e584a8584e087b8df621e9 inherit pro_attribs_classAbstractChordPeer"><td class="memItemLeft" align="right" valign="top"><a id="a1e890e9063e584a8584e087b8df621e9"></a>
<a class="el" href="classThreadSafeKey.html">ThreadSafeChordKey</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAbstractChordPeer.html#a1e890e9063e584a8584e087b8df621e9">min_key_</a></td></tr>
<tr class="memdesc:a1e890e9063e584a8584e087b8df621e9 inherit pro_attribs_classAbstractChordPeer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Minimum key held by this peer. <br /></td></tr>
<tr class="separator:a1e890e9063e584a8584e087b8df621e9 inherit pro_attribs_classAbstractChordPeer"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p><a class="el" href="dhash__peer_8h_source.html">dhash_peer.h</a></p>
<p>This file aims to implement a DHash peer, which should be capable of put and get operations, maintenance functions, stabilization, and running a server to respond to requests from other nodes. See Josh Cates' thesis: <a href="https://pdos.csail.mit.edu/papers/chord:cates-meng.pdf">https://pdos.csail.mit.edu/papers/chord:cates-meng.pdf</a> </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a27067dc2b5fbdcb151a639acbf2d75a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27067dc2b5fbdcb151a639acbf2d75a4">&#9670;&nbsp;</a></span>DHashPeer() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DHashPeer::DHashPeer </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>ip_addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>num_replicas</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Constructor 1. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ip_addr</td><td>IP addr on which server will run. </td></tr>
    <tr><td class="paramname">port</td><td>Port on which server will run. </td></tr>
    <tr><td class="paramname">num_replicas</td><td>The number of data fragments produced by <a class="el" href="classIDA.html">IDA</a> encoding (i.e. 14) and, by extension, the length of the succ- essor list to be maintained by the <a class="el" href="classDHashPeer.html">DHashPeer</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aabd3c7ed5300ab82c358ca133570c338"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aabd3c7ed5300ab82c358ca133570c338">&#9670;&nbsp;</a></span>DHashPeer() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">DHashPeer::DHashPeer </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDHashPeer.html">DHashPeer</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Disable copy construction. </p>

</div>
</div>
<a id="a0d1da6ff9c962aa535b83ff75a0a7a5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d1da6ff9c962aa535b83ff75a0a7a5b">&#9670;&nbsp;</a></span>~DHashPeer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DHashPeer::~DHashPeer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Destructor. Kill server, join threads. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a4d5c983633a793168ac00f1fc829bec1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d5c983633a793168ac00f1fc829bec1">&#9670;&nbsp;</a></span>AbsorbKeys()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void DHashPeer::AbsorbKeys </td>
          <td>(</td>
          <td class="paramtype">const Json::Value &amp;&#160;</td>
          <td class="paramname"><em>kv_pairs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Pure virtual function which has no use in this particular derivation. Will be left undefined. </p>

<p>Implements <a class="el" href="classAbstractChordPeer.html#a168639f841bc59e04e7b255b540d01b2">AbstractChordPeer</a>.</p>

</div>
</div>
<a id="a1813ce13acd42cb92909ac1e833a6ca7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1813ce13acd42cb92909ac1e833a6ca7">&#9670;&nbsp;</a></span>CompareNodes()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void DHashPeer::CompareNodes </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMerkleTree.html">DbEntry</a> &amp;&#160;</td>
          <td class="paramname"><em>remote_node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMerkleTree.html">DbEntry</a> &amp;&#160;</td>
          <td class="paramname"><em>local_node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classRemotePeer.html">RemotePeer</a> &amp;&#160;</td>
          <td class="paramname"><em>succ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const KeyRange &amp;&#160;</td>
          <td class="paramname"><em>key_range</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>If both remote node and local node are leaf nodes, determine if the local node is missing any keys in remote node, request those keys, and insert them into this node's db. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">remote_node</td><td>Merkle tree node from a predecessor looking to synchronize. </td></tr>
    <tr><td class="paramname">local_node</td><td>The equivalently-placed node in this node's index of the keyspace. </td></tr>
    <tr><td class="paramname">succ</td><td>The node requesting synchronization. </td></tr>
    <tr><td class="paramname">key_range</td><td>The range of keys which they are seeking to synchronize. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1721f42ca0b431e635bf65f9f6d5aec1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1721f42ca0b431e635bf65f9f6d5aec1">&#9670;&nbsp;</a></span>Create() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void DHashPeer::Create </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGenericKey.html">ChordKey</a> &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDataBlock.html">DataBlock</a> &amp;&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Contact the num_succs_ successor peers of the hashed key, instruct each to store a fragment from the given datablock. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Hashed key to insert into overlay. </td></tr>
    <tr><td class="paramname">val</td><td>The series of fragments comprising the IDA-encoded value. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0b0dda4296dac27a8e9cf2b5aacdb298"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b0dda4296dac27a8e9cf2b5aacdb298">&#9670;&nbsp;</a></span>Create() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void DHashPeer::Create </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGenericKey.html">ChordKey</a> &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Encode a given string value, insert a key and a value into the overlay network. Exists mainly for unit-testing purposes. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key of kv pair. </td></tr>
    <tr><td class="paramname">val</td><td>Unencoded string to insert into overlay. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8ee5dd5500b3a5fc1c379b957b602320"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ee5dd5500b3a5fc1c379b957b602320">&#9670;&nbsp;</a></span>Create() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void DHashPeer::Create </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Insert a key-value pair into the chord. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>The unhashed, human-readable key. </td></tr>
    <tr><td class="paramname">val</td><td>The value to which it corresponds. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classAbstractChordPeer.html#a3c66a38a972a8cb106f240f8d7409ac3">AbstractChordPeer</a>.</p>

</div>
</div>
<a id="ac0eb205320642065c6b675697210f073"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0eb205320642065c6b675697210f073">&#9670;&nbsp;</a></span>CreateKey()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool DHashPeer::CreateKey </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGenericKey.html">ChordKey</a> &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDataFragment.html">DataFragment</a> &amp;&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classRemotePeer.html">RemotePeer</a> &amp;&#160;</td>
          <td class="paramname"><em>peer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Instruct another DHash peer to store a key-value pair.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>The key for said peer to store. </td></tr>
    <tr><td class="paramname">val</td><td>The value of the KV pair. </td></tr>
    <tr><td class="paramname">peer</td><td>The remote DHash peer to store the KV pair. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on success, false on failure. </dd></dl>

</div>
</div>
<a id="abf5c11885e4d9967ed785529e6fbd63c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf5c11885e4d9967ed785529e6fbd63c">&#9670;&nbsp;</a></span>CreateKeyHandler()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Json::Value DHashPeer::CreateKeyHandler </td>
          <td>(</td>
          <td class="paramtype">const Json::Value &amp;&#160;</td>
          <td class="paramname"><em>req</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>When instructed by a remote peer to hold a key, insert it in our database and return a response indicating success/failure.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">req</td><td>Request indicating kv-pair to store in our db. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Success if key is in range, failure otherwise. </dd></dl>

</div>
</div>
<a id="a068cb23863c783eef59284990f9390b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a068cb23863c783eef59284990f9390b8">&#9670;&nbsp;</a></span>ExchangeNode()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classMerkleTree.html">DHashPeer::DbEntry</a> DHashPeer::ExchangeNode </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classRemotePeer.html">RemotePeer</a> &amp;&#160;</td>
          <td class="paramname"><em>succ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMerkleTree.html">DbEntry</a> &amp;&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const KeyRange &amp;&#160;</td>
          <td class="paramname"><em>key_range</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Send merkle tree node node to succ in pursuit of synchronizing key_range and receive the equivalently-placed merkle tree node of succ in return. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">succ</td><td>The successor with which we are synchronizing key_range. </td></tr>
    <tr><td class="paramname">node</td><td>The node which will be sent to succ and for which an equival- ently placed node will be returned. </td></tr>
    <tr><td class="paramname">key_range</td><td>The range of keys to synchronize with succ. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The merkle tree node of succ's database index with an identical position to node. </dd></dl>

</div>
</div>
<a id="ac060d8844b698e5829c1bc55c5f4d18d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac060d8844b698e5829c1bc55c5f4d18d">&#9670;&nbsp;</a></span>ExchangeNodeHandler()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Json::Value DHashPeer::ExchangeNodeHandler </td>
          <td>(</td>
          <td class="paramtype">const Json::Value &amp;&#160;</td>
          <td class="paramname"><em>request</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Given a request to exchange a node from our merkle tree, find the equiv- alently placed node, run CompareNodes on it and the remote node, and return the locally-stored node. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">request</td><td>Request specifying a remote merkle tree node. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>JSON response giving the equivalently-placed node in our merkle tree. </dd></dl>

</div>
</div>
<a id="a525294f074a2c18ffe34888554fc6fb2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a525294f074a2c18ffe34888554fc6fb2">&#9670;&nbsp;</a></span>Fail()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void DHashPeer::Fail </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Kill the server and maintenance_thread_, notify no one. </p>

<p>Implements <a class="el" href="classAbstractChordPeer.html">AbstractChordPeer</a>.</p>

</div>
</div>
<a id="ac8cd4bb0350bc4c25eddee0f4e27326a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8cd4bb0350bc4c25eddee0f4e27326a">&#9670;&nbsp;</a></span>ForwardRequest()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Json::Value DHashPeer::ForwardRequest </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGenericKey.html">ChordKey</a> &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Json::Value &amp;&#160;</td>
          <td class="paramname"><em>request</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Lookup the node owning key using finger table and successor list. Forward the request to that node. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key whose successor ought to receive request. </td></tr>
    <tr><td class="paramname">request</td><td>The request which should be forwarded. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The response from the successor of the key or throw an error if the key's successor cannot be found. </dd></dl>

<p>Implements <a class="el" href="classAbstractChordPeer.html#a20e2d5799d318f987ccc7a2a5781dee5">AbstractChordPeer</a>.</p>

</div>
</div>
<a id="a0e16b2bd33c041ca12d655b931a4b1aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e16b2bd33c041ca12d655b931a4b1aa">&#9670;&nbsp;</a></span>GetIdaParams()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::tuple&lt; int, int, int &gt; DHashPeer::GetIdaParams </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get parameters of information dispersal algorithm. </p><dl class="section return"><dt>Returns</dt><dd>(n, m, p) </dd></dl>

</div>
</div>
<a id="ab81aa53821650636d83a5e342085f297"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab81aa53821650636d83a5e342085f297">&#9670;&nbsp;</a></span>HandleNotifyFromPred()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Json::Value DHashPeer::HandleNotifyFromPred </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classRemotePeer.html">RemotePeer</a> &amp;&#160;</td>
          <td class="paramname"><em>new_pred</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Upon receiving a notify from the predecessor. This works the same as in <a class="el" href="classChordPeer.html">ChordPeer</a> - the peer sets its min_key_ to the predecessor's ID + 1 and the predecessor as its predecessor - but without the transfer of keys to the predecessor. In DHash, this will be handled during local and global maintenance. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">new_pred</td><td>The newly-joined node which is now our predecessor. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An indication to the predecessor that their request was success- fully processed. </dd></dl>

<p>Implements <a class="el" href="classAbstractChordPeer.html#adce07193a17a2f9d06ede71d487d0491">AbstractChordPeer</a>.</p>

</div>
</div>
<a id="a620c9ed5d88456741e9111b75895a537"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a620c9ed5d88456741e9111b75895a537">&#9670;&nbsp;</a></span>HandlePredFailure()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void DHashPeer::HandlePredFailure </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classRemotePeer.html">RemotePeer</a> &amp;&#160;</td>
          <td class="paramname"><em>old_pred</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Call rectify, set new pred. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">old_pred</td><td>The failed predecessor. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classAbstractChordPeer.html#aef38cdcd6c03143265be38def23c35ab">AbstractChordPeer</a>.</p>

</div>
</div>
<a id="a6ac5191636b286290773c15e59cb092c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ac5191636b286290773c15e59cb092c">&#9670;&nbsp;</a></span>IsMissing()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool DHashPeer::IsMissing </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGenericKey.html">ChordKey</a> &amp;&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const KeyRange &amp;&#160;</td>
          <td class="paramname"><em>key_range</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Is k in the key range and does is it missing from our db? </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">k</td><td>A key which may or may not be missing from our db. </td></tr>
    <tr><td class="paramname">key_range</td><td>A range of keys being synchronized. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If k is in the key range, does it not exist in our db? </dd></dl>

</div>
</div>
<a id="a0502c246336a328e9337fe7462bf9393"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0502c246336a328e9337fe7462bf9393">&#9670;&nbsp;</a></span>KeysAsJson()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Json::Value DHashPeer::KeysAsJson </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return empty JSON. </p>

<p>Implements <a class="el" href="classAbstractChordPeer.html#a684e44d679759c8fd045f3f5a0c01724">AbstractChordPeer</a>.</p>

</div>
</div>
<a id="a72b3488e32898089f02829c28f00632e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72b3488e32898089f02829c28f00632e">&#9670;&nbsp;</a></span>MaintenanceLoop()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void DHashPeer::MaintenanceLoop </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>A loop which runs local maintenance, global maintenance, and the stabilize protocol on a 5-second interval for as long as continue_maintenance_ is set to true. </p>

</div>
</div>
<a id="ad10928a0f127ad3a36a856d72c2aa9b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad10928a0f127ad3a36a856d72c2aa9b9">&#9670;&nbsp;</a></span>NeedsSync()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool DHashPeer::NeedsSync </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMerkleTree.html">DbEntry</a> &amp;&#160;</td>
          <td class="paramname"><em>remote_node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMerkleTree.html">DbEntry</a> &amp;&#160;</td>
          <td class="paramname"><em>local_node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const KeyRange &amp;&#160;</td>
          <td class="paramname"><em>key_range</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Are both the local and remote node in the range being synchronized, and do they have different hash values (indicating different data in subtree)? </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">remote_node</td><td>Merkle tree node from XCHNG_NODE req. </td></tr>
    <tr><td class="paramname">local_node</td><td>The equivalently-positioned local node from our index. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Are both nodes in the key range and do they have different hashes? </dd></dl>

</div>
</div>
<a id="a93a21ab8e833c3130a7c681ad847d8b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93a21ab8e833c3130a7c681ad847d8b3">&#9670;&nbsp;</a></span>Read() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDataBlock.html">DataBlock</a> DHashPeer::Read </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGenericKey.html">ChordKey</a> &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Find the num_succs_ successors of the key in the network, query each for its fragment of the given key, and reconstruct the original data block. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key to find in network. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The decoded value or throw an error if less than 10 fragments exist on the num_succs_ successors of the key. </dd></dl>

</div>
</div>
<a id="ad1aed5f28f1f6f4cd007238d69e823ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1aed5f28f1f6f4cd007238d69e823ba">&#9670;&nbsp;</a></span>Read() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string DHashPeer::Read </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Hash the provided key, gather its fragments from the overlay network, decode the fragments, and return the decoded fragment. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>The unhashed, human-readable key to lookup. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The decoded fragment or throw an error if lookup has failed. </dd></dl>

<p>Implements <a class="el" href="classAbstractChordPeer.html#a23b9c2eb426f8c5f2f6704ce90593dbb">AbstractChordPeer</a>.</p>

</div>
</div>
<a id="a891f9482080885d9196a0dd5582d6686"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a891f9482080885d9196a0dd5582d6686">&#9670;&nbsp;</a></span>ReadKey()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDataFragment.html">DataFragment</a> DHashPeer::ReadKey </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGenericKey.html">ChordKey</a> &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classRemotePeer.html">RemotePeer</a> &amp;&#160;</td>
          <td class="paramname"><em>peer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Contact a remote peer and instruct it to return the data fragment assoc- iated with a given key. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>The key whose corresponding data fragment ought be returned. </td></tr>
    <tr><td class="paramname">peer</td><td>The remote peer whose db will be queried. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The data fragment corresponding to the key if it exists, else throw an error. </dd></dl>

</div>
</div>
<a id="af657f5dd4b09ef15e52a2c0d0ffcdb6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af657f5dd4b09ef15e52a2c0d0ffcdb6b">&#9670;&nbsp;</a></span>ReadKeyHandler()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Json::Value DHashPeer::ReadKeyHandler </td>
          <td>(</td>
          <td class="paramtype">const Json::Value &amp;&#160;</td>
          <td class="paramname"><em>req</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>When instructed by a remote peer to return the value of a given key, return its value in a JSON response if it exists in our database, otherwise throw an error.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">req</td><td>Request indicating key to lookup. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>JSON response indicating value associated with key, if it exists, otherwise throw an error. </dd></dl>

</div>
</div>
<a id="a0160c1a8585b5cad3e65fc0269869488"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0160c1a8585b5cad3e65fc0269869488">&#9670;&nbsp;</a></span>ReadRange()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">DHashPeer::KvMap DHashPeer::ReadRange </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classRemotePeer.html">RemotePeer</a> &amp;&#160;</td>
          <td class="paramname"><em>succ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const KeyRange &amp;&#160;</td>
          <td class="paramname"><em>key_range</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Read the keys that succ holds that are within the specified range. The </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">succ</td><td>Successor to query. </td></tr>
    <tr><td class="paramname">key_range</td><td>The range of keys to search in the successor's merkle tree. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A map of k =&gt; v pairs from the successor. </dd></dl>

</div>
</div>
<a id="ac0e0205a816c06d7aa8d6c6dc7f64315"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0e0205a816c06d7aa8d6c6dc7f64315">&#9670;&nbsp;</a></span>ReadRangeHandler()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Json::Value DHashPeer::ReadRangeHandler </td>
          <td>(</td>
          <td class="paramtype">const Json::Value &amp;&#160;</td>
          <td class="paramname"><em>request</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Given a READ_RANGE request, find all trees stored in our merkle tree within the specified range, and return them. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">request</td><td>The request to read a certain range of keys from our index. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A JSON response of form { "[KEY]" : "[SERIALIZED_DATA_FRAG]" }. </dd></dl>

</div>
</div>
<a id="ae5cdede7851008e5183bc99ddbbb0839"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5cdede7851008e5183bc99ddbbb0839">&#9670;&nbsp;</a></span>RetrieveMissing()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void DHashPeer::RetrieveMissing </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGenericKey.html">ChordKey</a> &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>If this node ought to possess a key but does not, read the full data block, and insert a randomly chosen fragment of the data block into our db. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>The missing key. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aec950208fe2c1e7498a3f59564a29bf9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec950208fe2c1e7498a3f59564a29bf9">&#9670;&nbsp;</a></span>RunGlobalMaintenance()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void DHashPeer::RunGlobalMaintenance </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Protocol to push misplaced fragments to their correct nodes. Iterate through the database, find any fragments which this peer possesses but should not possess (i.e this peer is not in the num_succs_ = 14 succs of the given key), and push them to a successor of the key which does not have the key in question. </p>

</div>
</div>
<a id="ae435863093fde0cde366fe16cf90beea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae435863093fde0cde366fe16cf90beea">&#9670;&nbsp;</a></span>RunLocalMaintenance()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void DHashPeer::RunLocalMaintenance </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Protocol to ensure that all successors of this peer store replicas of the keys owned by this peer. Compare our database index (a merkle tree) with those of each successor, and recursively descend each tree node for which equivalently-placed hashes do not match. This will allow this node to synchronize a certain range of keys with a successor. </p>

</div>
</div>
<a id="ab6dbfe35b2d0fc6fd6a6e29f516c0009"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6dbfe35b2d0fc6fd6a6e29f516c0009">&#9670;&nbsp;</a></span>SetIdaParams()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void DHashPeer::SetIdaParams </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set parameters with which information is encoded in the <a class="el" href="classIDA.html">IDA</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>Number of total fragments generated by <a class="el" href="classIDA.html">IDA</a>. </td></tr>
    <tr><td class="paramname">m</td><td>Number of fragments needed to reconstruct an original. </td></tr>
    <tr><td class="paramname">p</td><td>Prime used for encoding purposes. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a912680ccaa6b09d390e83a325a2cbaa9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a912680ccaa6b09d390e83a325a2cbaa9">&#9670;&nbsp;</a></span>StartMaintenance()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void DHashPeer::StartMaintenance </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Start a thread to periodically run local maintenance, global maintenance, and stabilize. </p>

<p>Implements <a class="el" href="classAbstractChordPeer.html#abce2ccd25eff061667f2cb612cbf0748">AbstractChordPeer</a>.</p>

</div>
</div>
<a id="a7c06a83f3e8284a9f2a906ef290529d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c06a83f3e8284a9f2a906ef290529d4">&#9670;&nbsp;</a></span>Synchronize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void DHashPeer::Synchronize </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classRemotePeer.html">RemotePeer</a> &amp;&#160;</td>
          <td class="paramname"><em>succ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const KeyRange &amp;&#160;</td>
          <td class="paramname"><em>key_range</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Ensure that succ stores all of the keys that we store inside key range by synchronizing the root node (prompting recursive descent). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">succ</td><td>Successor with which we are synchronizing key_range. </td></tr>
    <tr><td class="paramname">key_range</td><td>The range of keys to synchronize with succ. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af795b89d0a2e23202e90efba685d8a9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af795b89d0a2e23202e90efba685d8a9c">&#9670;&nbsp;</a></span>SynchronizeHelper()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void DHashPeer::SynchronizeHelper </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classRemotePeer.html">RemotePeer</a> &amp;&#160;</td>
          <td class="paramname"><em>succ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const KeyRange &amp;&#160;</td>
          <td class="paramname"><em>key_range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMerkleTree.html">DbEntry</a> &amp;&#160;</td>
          <td class="paramname"><em>local_node</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Synchronize a specific merkle tree node with succ. Exchange nodes with the successor, and, if the hashes of two nodes do not match, recursively descend through the children of that node until we find the keys that succ is missing which we possess. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">succ</td><td>Successor with which this peer will synchronize. </td></tr>
    <tr><td class="paramname">key_range</td><td>The range of keys to synchronize (i.e. [min_key_, id_]). </td></tr>
    <tr><td class="paramname">local_node</td><td>The merkle tree node to exchange and recursively compare with the equivalently placed merkle tree node at succ. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="af7a8109daee7743c5c4b8dc62e0a4e70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7a8109daee7743c5c4b8dc62e0a4e70">&#9670;&nbsp;</a></span>db_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGenericDB.html">FragmentDb</a> DHashPeer::db_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>A DB consisting of a merkle tree index of the entire chord keyspace, with &lt;key, data-fragment&gt; pairs stored on leaf nodes. </p>

</div>
</div>
<a id="a630b7297b99632cd46ecc37a8e5f264d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a630b7297b99632cd46ecc37a8e5f264d">&#9670;&nbsp;</a></span>maintenance_thread_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::thread DHashPeer::maintenance_thread_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Thread which performs the stabilize operation every 5 seconds as outlined by Stoica. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>dhash/<a class="el" href="dhash__peer_8h_source.html">dhash_peer.h</a></li>
<li>dhash/dhash_peer.cpp</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>

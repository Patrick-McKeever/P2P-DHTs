#include <gtest/gtest.h>
#include "../src/ida/data_block.h"

TEST(Idk, sth)
{
    std::string b("Lorem ipsum dolor sit amet, consectetur adipiscing elit. Vivamus quis metus molestie orci placerat sagittis sed eu massa. Maecenas quam augue, venenatis quis quam ac, mattis placerat augue. Nullam vehicula, nibh eget consequat cursus, leo est viverra mauris, vel tempor lorem arcu vel neque. Ut elementum risus mauris, faucibus dapibus nulla maximus nec. Donec nec lorem velit. Morbi consequat dui at eros malesuada, at semper mi congue. Aenean maximus feugiat leo, quis porta nisi porta id. Nulla maximus odio non volutpat tristique. Pellentesque mollis velit consectetur mauris porta malesuada.\n");
    int num_segments = ceil(b.size() / 5.0);
    for(int i = 0; i < num_segments; ++i) {
        std::cout << i << ": " << b.substr(i * 5, 5) << std::endl;
    }
//    DataBlock a(b);
//    Json::StreamWriterBuilder writer_;
//    writer_["indentation"] = "";
//    std::string c = Json::writeString(writer_, a.fragments_.at(0).ToJson());
//    std::cout << c;
//    a.fragments_.at(0).WriteToFile("a.txt");
//    std::cout << a.Decode() << std::endl;
//
//    Json::Value encodedA(a);
//    DataBlock c(encodedA);
//    std::cout << a.Decode() << std::endl;
//    EXPECT_EQ(c.fragments_, a.fragments_);
//
//    std::cout << c.Decode();
}

//#include <gtest/gtest.h>
//#include "../src/data_structures/data_block.h"
//
///// Test classes and functions implemented in "src/data_block.h".
//
///// Does Gauss Elimination with Partial Pivoting work?
//TEST(PivotTest, Gaussian)
//{
//    TwoDimMatrix input = {
//			{1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0},
//			{1.0, 2.0, 4.0, 8.0, 16.0, 32.0, 64.0, 128.0, 256.0, 512.0},
//			{1.0, 3.0, 9.0, 27.0, 81.0, 243.0, 729.0, 2187.0, 6561.0, 19683.0},
//			{1.0, 4.0, 16.0, 64.0, 256.0, 1024.0, 4096.0, 16384.0, 65536.0,
//	         262144.0},
//			{1.0, 10.0, 100.0, 1000.0, 10000.0, 100000.0, 1000000.0, 1.0E7,
//	         1.0E8, 1.0E9},
//			{1.0, 6.0, 36.0, 216.0, 1296.0, 7776.0, 46656.0, 279936.0,
//	         1679616.0, 1.0077696E7},
//			{1.0, 7.0, 49.0, 343.0, 2401.0, 16807.0, 117649.0, 823543.0,
//	         5764801.0, 4.0353607E7},
//			{1.0, 8.0, 64.0, 512.0, 4096.0, 32768.0, 262144.0, 2097152.0,
//	         1.6777216E7, 1.34217728E8},
//			{1.0, 9.0, 81.0, 729.0, 6561.0, 59049.0, 531441.0, 4782969.0,
//	         4.3046721E7, 3.87420489E8},
//			{1.0, 14.0, 196.0, 2744.0, 38416.0, 537824.0, 7529536.0,
//	         1.05413504E8, 1.475789056E9, 2.0661046784E10}
//	};
//
//    TwoDimMatrix expected = {
//			{1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0},
//			{1.0, 1.0, 3.0, 7.0, 15.0, 31.0, 63.0, 127.0, 255.0, 511.0},
//			{1.0, 2.0, 2.0, 12.0, 50.0, 180.0, 602.0, 1932.0, 6050.0, 18660.0},
//			{1.0, 3.0, 3.0, 6.0, 60.0, 390.0, 2100.0, 10206.0, 46620.0,
//	         204630.0},
//			{1.0, 9.0, 36.0, 84.0, 25.2, 2.4, 0.017622377622377623, -9.6,
//	         -145152.0, -8128512.0},
//			{1.0, 5.0, 10.0, 10.0, 120.0, 1920.0, 19320.0, 157920.0, 1151640.0,
//	         7842240.0},
//			{1.0, 6.0, 15.0, 20.0, 3.0, 0.07142857142857142,
//	         -0.001048951048951049, 5040.0, 231840.0, 6320160.0},
//			{1.0, 7.0, 21.0, 35.0, 7.0, 0.3333333333333333,
//	         -0.0024475524475524478, 2.0000000000000013, -0.06944444444444405,
//	         -20160.00000000233},
//			{1.0, 8.0, 28.0, 56.0, 14.0, 5040.0, 126000.0, 1945440.0, 2.41416E7,
//	         2.6564328E8},
//			{1.0, 13.0, 78.0, 286.0, 143.0, 27.238095238095237, 686400.0,
//	         2.67696E7, 6.397248E8, 1.22440032E10}};
//
//    std::vector<int> index(input.size(), 0);
//    PartialPivotGaussElim(input, index);
//
//	EXPECT_EQ(input, expected);
//}
//
///// Does matrix inversion work?
//TEST(InvertTest, Matrix)
//{
//	TwoDimMatrix input = {
//			{1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0},
//			{1.0, 2.0, 4.0, 8.0, 16.0, 32.0, 64.0, 128.0, 256.0, 512.0},
//			{1.0, 3.0, 9.0, 27.0, 81.0, 243.0, 729.0, 2187.0, 6561.0, 19683.0},
//			{1.0, 4.0, 16.0, 64.0, 256.0, 1024.0, 4096.0, 16384.0, 65536.0,
//	         262144.0},
//			{1.0, 10.0, 100.0, 1000.0, 10000.0, 100000.0, 1000000.0, 1.0E7,
//	         1.0E8, 1.0E9},
//			{1.0, 6.0, 36.0, 216.0, 1296.0, 7776.0, 46656.0, 279936.0,
//	         1679616.0, 1.0077696E7},
//			{1.0, 7.0, 49.0, 343.0, 2401.0, 16807.0, 117649.0, 823543.0,
//	         5764801.0, 4.0353607E7},
//			{1.0, 8.0, 64.0, 512.0, 4096.0, 32768.0, 262144.0, 2097152.0,
//	         1.6777216E7, 1.34217728E8},
//			{1.0, 9.0, 81.0, 729.0, 6561.0, 59049.0, 531441.0, 4782969.0,
//	         4.3046721E7, 3.87420489E8},
//			{1.0, 14.0, 196.0, 2744.0, 38416.0, 537824.0, 7529536.0,
//	         1.05413504E8, 1.475789056E9, 2.0661046784E10}
//	    };
//
//	TwoDimMatrix expected = {
//			{8.61538461538454, -31.499999999999478, 61.09090909090696,
//	         -58.79999999999727, 3.499999999999446, 73.49999999999399,
//	         -95.99999999999079, 62.99999999999264, -22.39999999999714,
//	         -0.006293706293704852},
//			{-15.51111111111091, 72.46249999999857, -150.71515151514566,
//	         149.963333333326, -9.4513888888874, -193.57916666665062,
//	         255.12380952378462, -168.54999999998054, 60.23999999999231,
//	         0.01717532467532081},
//			{11.745177045176833, -63.42455357142702, 143.03347763347134,
//	         -148.53333333332552, 10.127728174601598, 200.26701388887196,
//	         -267.26666666664005, 178.24285714283675, -64.17301587300766,
//	         -0.018684440559436483},
//			{-4.931935965269182, 29.263417658729267, -70.57806637806286,
//	         76.68796296295855, -5.762304343032632, -108.89878472221277,
//	         147.6497354497205, -99.67103174602038, 36.23015873015407,
//	         0.01084835303585078},
//			{1.2711233211232835, -8.048226686507634, 20.45930735930621,
//	         -23.163888888887424, 1.9437624007933645, 34.77005208333022,
//	         -48.02698412697921, 32.900992063488296, -12.102380952379399,
//	         -0.0037565732878225523},
//			{-0.2093508343508268, 1.3888702876983503, -3.6781385281382954,
//	         4.313263888888589, -0.40706638558195296, -6.835286458332701,
//	         9.635714285713286, -6.713343253967482, 2.5045238095234907,
//	         8.131885475633988E-4},
//			{0.022107753357752405, -0.15183531746030954, 0.41520562770559816,
//	         -0.5013888888888506, 0.05332341269840545, 0.8354166666665864,
//	         -1.202579365079238, 0.8533730158729174, -0.3235119047618642,
//	         -1.1100011100009216E-4},
//			{-0.0014473951973951239, 0.01020585317460257, -0.02862554112553886,
//	         0.03541666666666372, -0.004236937830687277, -0.061718749999993834,
//	         0.0906746031745934, -0.06557539682538925, 0.025297619047615932,
//	         9.278915528914082E-6},
//			{5.34188034188003E-5, -3.844246031745776E-4, 0.0011002886002885047,
//	         -0.0013888888888887638, 1.8601190476188136E-4,
//	         0.0025173611111108498, -0.0037698412698408557,
//	         0.002777777777777457, -0.0010912698412697092,
//	         -4.3359418359412234E-7},
//			{-8.479175145841257E-7, 6.200396825396368E-6,
//	         -1.8037518037516333E-5, 2.3148148148145914E-5,
//	         -3.4446649029978186E-6, -4.340277777777311E-5,
//	         6.613756613755874E-5, -4.960317460316888E-5, 1.9841269841267483E-5,
//	         8.671883671882578E-9}
//	    };
//
//    EXPECT_EQ(Invert(input), expected);
//}
//
///// Can IDA properly encode a 1-D matrix?
//TEST(IdaTest, Encode)
//{
//    OneDimMatrix message = {12, 23, 34, 5,  3,  4,  2,  4, 23, 21,
//                            12, 13, 9,  12, 19, 17, 27, 6, 23, 26,
//                            12, 23, 34, 5,  3,  4,  2,  4, 23, 21,
//                            12, 13, 9,  12, 19, 17, 27, 6, 23, 26};
//
//    TwoDimMatrix expected = {
//			{131.0, 164.0, 131.0, 164.0},
//			{17690.0, 22714.0, 17690.0, 22714.0},
//			{576189.0, 701592.0, 576189.0, 701592.0},
//			{7091912.0, 8555216.0, 7091912.0, 8555216.0},
//			{5.0359727E7, 6.0723052E7, 5.0359727E7, 6.0723052E7},
//			{2.51513286E8, 3.03750414E8, 2.51513286E8, 3.03750414E8},
//			{9.83623625E8, 1.190237984E9, 9.83623625E8, 1.190237984E9},
//			{3.213509444E9, 3.895839412E9, 3.213509444E9, 3.895839412E9},
//			{9.146362107E9, 1.1107192116E10, 9.146362107E9, 1.1107192116E10},
//			{2.3342438642E10, 2.8388903042E10, 2.3342438642E10,
//	         2.8388903042E10},
//			{5.4529346741E10, 6.6404682664E10, 5.4529346741E10,
//	         6.6404682664E10},
//			{1.1839533696E11, 1.44344126904E11, 1.1839533696E11,
//	         1.44344126904E11},
//			{2.41718528999E11, 2.94992487932E11, 2.41718528999E11,
//	         2.94992487932E11},
//			{4.68264131102E11, 5.71976050966E11, 4.68264131102E11,
//	         5.71976050966E11}
//	    };
//
//    IDA ida(14, 10, 40);
//    EXPECT_EQ(ida.Encode(message), expected);
//};
//
///// Can IDA properly parse and decode a serialized str?
//TEST(IdaTest, ParseAndDecodeStr)
//{
//    std::string mess =
//            "1:131.0 164.0 131.0 164.0\n"
//            "2:17690.0 22714.0 17690.0 22714.0\n"
//            "3:576189.0 701592.0 576189.0 701592.0\n"
//            "4:7091912.0 8555216.0 7091912.0 8555216.0\n"
//            "10:2.3342438642E10 2.8388903042E10 2.3342438642E10 "
//            "2.8388903042E10\n"
//            "6:2.51513286E8 3.03750414E8 2.51513286E8 3.03750414E8\n"
//            "7:9.83623625E8 1.190237984E9 9.83623625E8 1.190237984E9\n"
//            "8:3.213509444E9 3.895839412E9 3.213509444E9 3.895839412E9\n"
//            "9:9.146362107E9 1.1107192116E10 9.146362107E9 1.1107192116E10\n"
//            "14:4.68264131102E11 5.71976050966E11 4.68264131102E11 "
//            "5.71976050966E11";
//    std::string expected = "12 23 34 5 3 4 2 4 23 21 12 13 9 12 19 17 27 6 23 26 "
//                           "12 23 34 5 3 4 2 4 23 21 12 13 9 12 19 17 27 6 23 26 ";
//    IDA ida(14, 10, 40);
//    EXPECT_EQ(ida.DecodeAsStr(mess), expected);
//}
//
///// Can the IDA encode a string, decode the encoded version, and produce
///// a one-d matrix identical to the input?
//TEST(IdaTest, Decode)
//{
//    OneDimMatrix message = {12, 23, 34, 5,  3,  4,  2,  4, 23, 21,
//                            12, 13, 9,  12, 19, 17, 27, 6, 23, 26,
//                            12, 23, 34, 5,  3,  4,  2,  4, 23, 21,
//                            12, 13, 9,  12, 19, 17, 27, 6, 23, 26};
//    IDA ida(14, 10, 40);
//    TwoDimMatrix encoded = ida.Encode(message);
//	std::vector<int> indices = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
//	TwoDimMatrix first_ten_frags(encoded.cbegin(), encoded.cbegin() + 10);
//	OneDimMatrix result = ida.Decode(first_ten_frags, indices);
//
//	EXPECT_EQ(message, result);
//}
//
///// Does the DataBlock constructor from a vector of DataFragments work?
//TEST(DataBlock, FromFragments)
//{
//	DataBlock data_block1("abcd", true);
//	std::vector<DataFragment> frag_list(data_block1.fragments_.cbegin(),
//	                                    data_block1.fragments_.cbegin() + 10);
//	DataBlock data_block2(frag_list);
//	EXPECT_EQ(data_block1, data_block2);
//}
//
///// Does the DataBlock constructor from a serialized str work?
//TEST(DataBlock, FromSerializedStr)
//{
//    DataBlock data_block1("abcd", true);
//	std::string encoded_block(data_block1);
//	DataBlock data_block2(encoded_block);
//	EXPECT_EQ(data_block1, data_block2);
//}
//
///// Can DataBlock correctly encode and decode a string?
//TEST(DataBlock, DecodeTest)
//{
//	std::string input_str = "abcd";
//    DataBlock data_block(input_str, true);
//    EXPECT_EQ(input_str, data_block.Decode());
//}
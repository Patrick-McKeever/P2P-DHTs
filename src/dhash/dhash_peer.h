/**
 * dhash_peer.h
 *
 * This file aims to implement a DHash peer, which should be capable of
 * put and get operations, maintenance functions, stabilization, and running
 * a server to respond to requests from other nodes.
 */

#ifndef CHORD_AND_DHASH_DHASH_PEER_H
#define CHORD_AND_DHASH_DHASH_PEER_H

#include <gtest/gtest.h>
#include "../chord/abstract_chord_peer.h"
#include "../networking/server.h"

/**
 * See Josh Cates' thesis:
 * https://pdos.csail.mit.edu/papers/chord:cates-meng.pdf
 */
class DHashPeer : public AbstractChordPeer {
public:
    using KeyRange = std::pair<ChordKey, ChordKey>;
    using DbEntry = MerkleTree<DataFragment>;
    using KvMap = std::map<ChordKey, DataFragment>;
    using KvPair = std::pair<ChordKey, DataFragment>;

    /**
     * Constructor 1.
     * @param ip_addr IP addr on which server will run.
     * @param port Port on which server will run.
     * @param num_replicas The number of data fragments produced by IDA encoding
     *                     (i.e. 14) and, by extension, the length of the succ-
     *                     essor list to be maintained by the DHashPeer.
     */
    DHashPeer(std::string ip_addr, int port, int num_replicas);

    /**
     * Disable copy construction.
     */
    DHashPeer(const DHashPeer &rhs) = delete;

    DHashPeer(DHashPeer &&rhs) noexcept;

    /**
     * Destructor. Kill server, join threads.
     */
    ~DHashPeer();

    /**
     * Insert a key-value pair into the chord.
     * @param key The unhashed, human-readable key.
     * @param val The value to which it corresponds.
     */
    void Create(const std::string &key, const std::string &val) override;

    /**
     * Hash the provided key, gather its fragments from the overlay network,
     * decode the fragments, and return the decoded fragment.
     * @param key The unhashed, human-readable key to lookup.
     * @return The decoded fragment or throw an error if lookup has failed.
     */
    std::string Read(const std::string &key) override;

    /**
     * Kill the server and maintenance_thread_, notify no one.
     */
    void Fail() override;

    /**
     * Get parameters of information dispersal algorithm.
     * @return (n, m, p)
     */
    std::tuple<int, int, int> GetIdaParams() const;

    /**
     * Set parameters with which information is encoded in the IDA.
     * @param n Number of total fragments generated by IDA.
     * @param m Number of fragments needed to reconstruct an original.
     * @param p Prime used for encoding purposes.
     */
    void SetIdaParams(int n, int m, int p);

protected:
    using ReqHandler = std::function<Json::Value(const Json::Value &)>;
    using ServerType = Server<ReqHandler>;

    /**
     * Contact the num_succs_ successor peers of the hashed key, instruct
     * each to store a fragment from the given datablock.
     * @param key Hashed key to insert into overlay.
     * @param val The series of fragments comprising the IDA-encoded value.
     */
    void Create(const ChordKey &key, const DataBlock &val);


    /**
     * Encode a given string value, insert a key and a value into the overlay
     * network. Exists mainly for unit-testing purposes.
     * @param key Key of kv pair.
     * @param val Unencoded string to insert into overlay.
     */
    void Create(const ChordKey &key, const std::string &val);

    /**
     * Instruct another DHash peer to store a key-value pair.
     *
     * @param key The key for said peer to store.
     * @param val The value of the KV pair.
     * @param peer The remote DHash peer to store the KV pair.
     * @return true on success, false on failure.
     */
    bool CreateKey(const ChordKey &key, const DataFragment &val,
                   const RemotePeer &peer);

    /**
     * When instructed by a remote peer to hold a key, insert it in our database
     * and return a response indicating success/failure.
     *
     * @param req Request indicating kv-pair to store in our db.
     * @return Success if key is in range, failure otherwise.
     */
    Json::Value CreateKeyHandler(const Json::Value &req);

    /**
     * Find the num_succs_ successors of the key in the network, query each for
     * its fragment of the given key, and reconstruct the original data block.
     * @param key Key to find in network.
     * @return The decoded value or throw an error if less than 10 fragments
     *         exist on the num_succs_ successors of the key.
     */
    DataBlock Read(const ChordKey &key);

    /**
     * Contact a remote peer and instruct it to return the data fragment assoc-
     * iated with a given key.
     * @param key The key whose corresponding data fragment ought be returned.
     * @param peer The remote peer whose db will be queried.
     * @return The data fragment corresponding to the key if it exists, else
     *         throw an error.
     */
    DataFragment ReadKey(const ChordKey &key, const RemotePeer &peer);

    /**
     * When instructed by a remote peer to return the value of a given key,
     * return its value in a JSON response if it exists in our database,
     * otherwise throw an error.
     *
     * @param req Request indicating key to lookup.
     * @return JSON response indicating value associated with key, if it
     *         exists, otherwise throw an error.
     */
    Json::Value ReadKeyHandler(const Json::Value &req);

    /**
     * Read the keys that succ holds that are within the specified range. The
     * @param succ Successor to query.
     * @param key_range The range of keys to search in the successor's merkle
     *                  tree.
     * @return A map of k => v pairs from the successor.
     */
    static KvMap ReadRange(const RemotePeer &succ, const KeyRange &key_range);

    /**
     * Given a READ_RANGE request, find all trees stored in our merkle tree
     * within the specified range, and return them.
     * @param request The request to read a certain range of keys from our index.
     * @return A JSON response of form { "[KEY]" : "[SERIALIZED_DATA_FRAG]" }.
     */
    Json::Value ReadRangeHandler(const Json::Value &request);

    /**
     * Upon receiving a notify from the predecessor. This works the same as in
     * ChordPeer - the peer sets its min_key_ to the predecessor's ID + 1 and
     * the predecessor as its predecessor - but without the transfer of keys
     * to the predecessor. In DHash, this will be handled during local and
     * global maintenance.
     * @param new_pred The newly-joined node which is now our predecessor.
     * @return An indication to the predecessor that their request was success-
     *         fully processed.
     */
    Json::Value HandleNotifyFromPred(const RemotePeer &new_pred) override;

    /**
     * Call rectify, set new pred.
     * @param old_pred The failed predecessor.
     */
    void HandlePredFailure(const RemotePeer &old_pred) override;

    /**
     * Start a thread to periodically run local maintenance, global maintenance,
     * and stabilize.
     */
    void StartMaintenance() override;

    /**
     * A loop which runs local maintenance, global maintenance, and the
     * stabilize protocol on a 5-second interval for as long as
     * continue_maintenance_ is set to true.
     */
    void MaintenanceLoop();

    /**
     * Protocol to push misplaced fragments to their correct nodes. Iterate
     * through the database, find any fragments which this peer possesses but
     * should not possess (i.e this peer is not in the num_succs_ = 14 succs
     * of the given key), and push them to a successor of the key which does
     * not have the key in question.
     */
    void RunGlobalMaintenance();

    /**
     * Protocol to ensure that all successors of this peer store replicas of
     * the keys owned by this peer. Compare our database index (a merkle tree)
     * with those of each successor, and recursively descend each tree node
     * for which equivalently-placed hashes do not match. This will allow this
     * node to synchronize a certain range of keys with a successor.
     */
    void RunLocalMaintenance();

    /**
     * Ensure that succ stores all of the keys that we store inside key range
     * by synchronizing the root node (prompting recursive descent).
     * @param succ Successor with which we are synchronizing key_range.
     * @param key_range The range of keys to synchronize with succ.
     */
    void Synchronize(const RemotePeer &succ, const KeyRange &key_range);

    /**
     * Synchronize a specific merkle tree node with succ. Exchange nodes with
     * the successor, and, if the hashes of two nodes do not match, recursively
     * descend through the children of that node until we find the keys that
     * succ is missing which we possess.
     * @param succ Successor with which this peer will synchronize.
     * @param key_range The range of keys to synchronize (i.e. [min_key_, id_]).
     * @param local_node The merkle tree node to exchange and recursively
     *                   compare with the equivalently placed merkle tree node
     *                   at succ.
     */
    void SynchronizeHelper(const RemotePeer &succ, const KeyRange &key_range,
                           const DbEntry &local_node);

    /**
     * Send merkle tree node node to succ in pursuit of synchronizing key_range
     * and receive the equivalently-placed merkle tree node of succ in return.
     * @param succ The successor with which we are synchronizing key_range.
     * @param node The node which will be sent to succ and for which an equival-
     *             ently placed node will be returned.
     * @param key_range The range of keys to synchronize with succ.
     * @return The merkle tree node of succ's database index with an identical
     *         position to node.
     */
    DbEntry ExchangeNode(const RemotePeer &succ, const DbEntry &node,
                         const KeyRange &key_range);

    /**
     * Given a request to exchange a node from our merkle tree, find the equiv-
     * alently placed node, run CompareNodes on it and the remote node, and
     * return the locally-stored node.
     * @param request Request specifying a remote merkle tree node.
     * @return JSON response giving the equivalently-placed node in our merkle
     *         tree.
     */
    Json::Value ExchangeNodeHandler(const Json::Value &request);

    /**
     * If both remote node and local node are leaf nodes, determine if the local
     * node is missing any keys in remote node, request those keys, and insert
     * them into this node's db.
     * @param remote_node Merkle tree node from a predecessor looking to
     *                    synchronize.
     * @param local_node The equivalently-placed node in this node's index of
     *                   the keyspace.
     * @param succ The node requesting synchronization.
     * @param key_range The range of keys which they are seeking to synchronize.
     */
    void CompareNodes(const DbEntry &remote_node, const DbEntry &local_node,
                      const RemotePeer &succ, const KeyRange &key_range);

    /**
     * Are both the local and remote node in the range being synchronized, and
     * do they have different hash values (indicating different data in subtree)?
     * @param remote_node Merkle tree node from XCHNG_NODE req.
     * @param local_node The equivalently-positioned local node from our index.
     * @return Are both nodes in the key range and do they have different hashes?
     */
    static bool NeedsSync(const DbEntry &remote_node, const DbEntry &local_node,
                          const KeyRange &key_range);

    /**
     * Is k in the key range and does is it missing from our db?
     * @param k A key which may or may not be missing from our db.
     * @param key_range A range of keys being synchronized.
     * @return If k is in the key range, does it not exist in our db?
     */
    bool IsMissing(const ChordKey &k, const KeyRange &key_range);

    /**
     * If this node ought to possess a key but does not, read the full data
     * block, and insert a randomly chosen fragment of the data block into our
     * db.
     * @param key The missing key.
     */
    void RetrieveMissing(const ChordKey &key);

    /**
     * Pure virtual function which has no use in this particular derivation.
     * Will be left undefined.
     */
    void AbsorbKeys(const Json::Value &kv_pairs) override;

    /**
     * Return empty JSON.
     */
    Json::Value KeysAsJson() override;

    /**
     * Lookup the node owning key using finger table and successor list. Forward
     * the request to that node.
     * @param key Key whose successor ought to receive request.
     * @param request The request which should be forwarded.
     * @return The response from the successor of the key or throw an error
     *         if the key's successor cannot be found.
     */
    Json::Value ForwardRequest(const ChordKey &key,
                               const Json::Value &request) override;

    /// A DB consisting of a merkle tree index of the entire chord keyspace,
    /// with <key, data-fragment> pairs stored on leaf nodes.
    FragmentDb db_;

    /// Thread which performs the stabilize operation every 5 seconds as
    /// outlined by Stoica.
    std::thread maintenance_thread_;

    /// Server to respond to queries from other nodes.
    std::shared_ptr<ServerType> server_;

    /// Stabilize thread will run while this is true.
    bool continue_maintenance_;

    int n_, m_, p_;

private:
    FRIEND_TEST(DHashSynchronize, AllKeysInRange);
    FRIEND_TEST(DHashSynchronize, SynchronizeUsesGivenRange);
    FRIEND_TEST(DHashSynchronize, HighDepth);
    FRIEND_TEST(DHashGlobalMaintenance, MisplacedKeys);
    FRIEND_TEST(DHashExchangeNode, ExistingNode);
    FRIEND_TEST(DHashExchangeNode, NonExistentNode);
    FRIEND_TEST(DHashGlobalMaintenance, NoNeedToCorrect);
};


#endif

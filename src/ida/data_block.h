#ifndef CHORD_AND_DHASH_DATA_BLOCK_H
#define CHORD_AND_DHASH_DATA_BLOCK_H

#include "matrix_math.h"
#include "data_fragment.h"
#include "ida.h"
#include <string>

/**
 * The DataBlock class represents a piece of data corresponding to a key.
 * Its implementation should allow the ability to:
 *      - Encode into fragments using an information dispersal algorithm.
 *      - Decode from only a fraction of the total fragments generated for
 *        any given block (e.g. 14 fragments generated, only 10 needed to
 *        decode.
 *      - Serialize as a string.
 *      - Construct from a serialized string (e.g. parse the string).
 *      - Construct from a vector of DataFragments.
 * This will enable replication of data on multiple peers.
 */
class DataBlock {
public:
    /**
     * Constructor #1.
     * Create a data block by first encoding an input string as a vector of
     * doubles corresponding to its characters' UTF codes, then encode
     * that vector as data fragments.
     *
     * @param input String to encode.
     * @param n Total number fragments generated by IDA.
     * @param m Minimum number of fragments needed to reconstruct the original.
     */
    explicit DataBlock(const std::string &input, int n = 14, int m = 10,
                       int p = 257);

    /**
     * Constructor #2.
     * After a data block has been serialized into JSON, take that JSON and
     * construct a data block from it.
     *
     * @param json_block Json-encoded data block.
     */
    explicit DataBlock(const Json::Value &json_block);

    /**
     * Constructor #4.
     * Decode from an array of data fragments.
     *
     * @param fragments An array of data fragments.
     */
    explicit DataBlock(const std::vector<DataFragment> &fragments, int n = 14,
                       int m = 10, int p = 257);

    /**
     * Cast data block to JSON.
     * @return Json-encoded version of the block specifying n, m, p, and the
     * block's JSON-encoded data-fragments.
     */
    explicit operator Json::Value() const;

    /**
     * Convert data block into string.
     * (Will there be issues that we're giving constructor 2 14 els instead of 10?
     * @return Data block serialzied in form:
     *      [FRAG_1]:[num_1] [num_2]...[num_(p_/m_)]
     *      [FRAG_2]:[num_1] [num_2]...[num_(p_/m_)]
     *      ...
     *      [FRAG_(n_)]:[num_1] [num_2]...[num_(p_/m_)]
     */
    explicit operator std::string() const;

    /**
     * Convert DataBlock to string by decoding "original_".
     *
     * @return The string used to create this DataBlock - i.e. the argument
     *         passed as "input" to the first constructor.
     */
    [[nodiscard]] std::string Decode() const;

    /**
     * Comparison operator (for unit tests).
     *
     * @param db1 Lefthand.
     * @param db2 Righthand.
     * @return Equality of left and right hand.
     */
    friend bool operator == (const DataBlock &db1, const DataBlock &db2);

    /// Parameters of the IDA used to encode this block.
    int n_, m_, p_;

    IDA ida_;

    /// The original string translated into a vector of doubles, with
    /// the nth double corresponding to string's nth char's UTF code.
    Vector original_;

    /// A two-d vector containing one-d vectors of doubles, with each one-d
    /// double vector representing a "fragment". These can be decoded into
    /// a single one-d double vector ("original_"), which can in turn be
    /// decoded into a string.
    std::vector<DataFragment> fragments_;
};

#endif